# 项目概述：
WebServer 是一个网络容器，模拟 Tomcat 的基础功能。

网络容器的主要功能： 

1. 接收用户请求，调用 Servlet, 响应客户端。
2. 内部维护若干 servlet

## 1. 新建 Maven jar 工程

## 2. 新建`com.webserver.core`包

## 3. 创建 WebServer 类
- 启动服务器
- 获取 serverSocket 实例
- 获取 socket 实例
- 获取输出流


# 创建一个 ClientHandler
> 总体的思路 分三步：
> 1. 解析请求
> 2. 处理请求
> 3. 响应客户端



# 一、解析请求：
服务端应当可以接受多个客户端的请求，
所以用线程处理客户端的请求。
定义一个 ClientHandler 类。





> 设计一个 HttpRequest 类，用来封装一个请求
 - 创建一个 com.webserver.http 包
 - 定义一个 HttpRequest 类
    + 定义属性
    + 构造方法
    + 在 ClientHandler 中实例化 HTTPRequest， 完成解析请求的工作


## 解析请求行
1. 通过输入流获取第一行字符串
2. 将这行字符串按空格拆分为三部分。
3. 拆分后的字符串赋值给属性。

> 经常用到读取一行，索性将他封装为一个私有方法 readLine();




### 找 BUG， 哈哈哈
```java
    private String readLine() throws IOException {
        int d = -1; 
        StringBuilder builder = new StringBuilder();
        while ((d = in.read())!=-1) { // 一直读到 文件末尾 EOF
            char chr = (char)d;
            /* 如果读到行尾，就break; 
             * 一开始，是不会读到 crlf 的
             * 
             * 要确保 builder.length() - 1 >= 0
             */
        
            if(builder.length()!=0&&builder.charAt(builder.length()-1)==13&&chr==10) {
                break;
            }
            builder.append(d);
        }
        return builder.toString().trim();
    }
```

应该是是`builder.append(chr)`。

## 解析消息头
用 Map 来储存消息头。

编译版本，改成 1.7 以上。 1.8 就好。

Java Compiler --> Complier Compiliance Level : 1.8

一直读取到消息头的最后一行

# 二、处理请求

分析用户的请求，根据其请求路径找到对应的资源。

1. 新建一个目录： webapps, 用以保存静态资源。
2. webapps 目录下新建一个子目录：myweb.
3. myweb目录下新建一个页面：index.html.

4. 浏览器地址栏输入`http://localhost:8088/myweb/index.html`


## ClientHandler 中处理请求

1. 从 HttpRequest 对象中获取 uri. 根据 uri 得到抽象路径
2. 根据抽象路径寻找 webapp 下的资源，判断资源是够存在
    - 存在，就返回请求的资源
        + 实例化一个 Response 对象，
        + 请求的资源通过 response 对象传入，setEntity 方法。
        
    - 不存在，就返回 404 页面

# 三、响应客户端
发送一个标准的响应，至客户端。

- 一个标准的响应，由三部分构成。
    + 状态行
        * 协议版本
        * 状态码
        * 状态描述
    + 响应头
    + 响应正文：二进制字节，**并不要求字符集是 ISO8859-1**

## 步骤
1. 通过 socket 获取输出流。
2. 输出状态行
    - `HTTP/1.1 200 OK`
3. 输出响应头
    - Content-Type:
    - Content-Size:
4. 输出请求的文件



## 创建一个 HttpResponse 类，响应客户端。

- 与连接相关的属性：
    + socket
    + outputStream

- 响应客户端的方法：flush()
    + sendStatusLine(): 发送状态行
    + sendHeaders()：发送响应头
    + sendContent()：发送响应正文，块读块写  
    + writeCRLF():  将输出回车换行的代码，提取为一个本地私有方法，提高代码重用。

- 构造方法中会调用 flush() 方法，向客户端发送一个标准的 HTTP 响应。


## 响应 404 页面
- 像 404 这种页面，容器中的各个网络应用都会用到，不如把它放在一个单独的文件夹里。
- 同时应该避免用户直接访问到 404 页面。

- 新建404页面，路径：`webapps/root/404.html`


### HttpResponse 类中， 将状态码和状态描述封装到两个属性中。
```java
    private int statusCode = 200;
    private String statusReason = "OK";
    
    
    public void setStatusCode(int statusCode) {
        this.statusCode = statusCode;
    }
    public void setStatusReason(String statusReason) {
        this.statusReason = statusReason;
    }

```

- sendStatusLine()中代码小小更改一下：
`"HTTP/1.1 200 OK"`
-->
`"HTTP/1.1 " + statusCode + " " + statusReason`

### 响应 404 页面

资源不存在:
- 设置响应码 和 响应描述
- 给客户端返回 404 页面

# 至此，解析请求、处理请求、响应客户端全部完成
大致流程，如下代码所示：
```java
public void run() {
    try {
        // 1. 解析请求
        HttpRequest request = new HttpRequest(socket);
        
        // 2. 处理请求
        String path = request.getUri();
        System.out.println("path: " + path);
        //   2.x 实例化一个响应
        HttpResponse response = new HttpResponse(socket);
        File file = new File("webapps" + path);
        if (file.exists()) {
            System.out.println("该资源已经找");
            response.setEntity(file);
        } else {
            System.out.println("该资源不存在");
            // 设置状态码和状态描述
            response.setStatusCode(404);
            response.setStatusReason("NOT FOUND");
            // 准备一个 404 页面
            File notFoundPage = new File("webapps/root/404.html");
            response.setEntity(notFoundPage);
        }

        // 3. 响应客户端
        response.flush();
    } catch (Exception e) {
    }
}
```

# 响应头优化

当前版本，响应类型是固定的`text/html`. 对于其他类型的资源，浏览器就无法正确处理了。

解决此问题的思路：
1. sendHeaders() 方法中不应当是固定的，应当是根据属性来的。所以用一个`private Map<String:String> headers;`属性来封装。
2. 根据用户请求的资源的后缀名，来设置`Content-Type`。







































